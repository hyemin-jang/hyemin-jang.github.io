{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm/[백준]18352/","result":{"data":{"site":{"siteMetadata":{"title":"Hyem.log","author":"[hyem]","siteUrl":"https://hyemin-jang.github.io","comment":{"disqusShortName":"","utterances":"hyemin-jang/hyemin-jang.github.io"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"e5952fe4-2733-5b80-b39e-325ffbb8c838","excerpt":"문제 문제 링크 풀이 처음에는 저번에 다익스트라 알고리즘을 공부하며 썼던 포스팅에서 썼던 예시 코드를 그대로 적용해서 풀어봤는데 시간초과로 실패했다 ㅠ  생각해보니까 예시 코드의 상황과 달리 각 도시는 단방향으로만 연결된다 각 도시 사이의 모든 거리는 1이다 라는 조건이 있는데 이를 고려하지 않고 쓸모없는 계산들을 많이 해서 그런 것 같다. 결국 God…","html":"<h1 id=\"문제\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C\" aria-label=\"문제 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제</h1>\n<p><a href=\"https://www.acmicpc.net/problem/18352\">문제 링크</a></p>\n<h1 id=\"풀이\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4\" aria-label=\"풀이 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이</h1>\n<p>처음에는 저번에 다익스트라 알고리즘을 공부하며 썼던 <a href=\"https://hyemin-jang.github.io/Algorithm/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/\">포스팅</a>에서 썼던 예시 코드를 그대로 적용해서 풀어봤는데 시간초과로 실패했다 ㅠ </p>\n<p>생각해보니까 예시 코드의 상황과 달리</p>\n<ul>\n<li>각 도시는 단방향으로만 연결된다</li>\n<li>각 도시 사이의 모든 거리는 1이다</li>\n</ul>\n<p>라는 조건이 있는데 이를 고려하지 않고 쓸모없는 계산들을 많이 해서 그런 것 같다.</p>\n<p>결국 God구글의 도움을 받아 완성한 코드..</p>\n<h3 id=\"-다익스트라-알고리즘-사용\" style=\"position:relative;\"><a href=\"#-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9\" aria-label=\" 다익스트라 알고리즘 사용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✅ 다익스트라 알고리즘 사용</h3>\n<blockquote>\n<p>💡 <strong>다익스트라 알고리즘 복습!</strong></p>\n<ol>\n<li>출발 노드를 설정한다</li>\n<li>비용 리스트를 (무한으로) 초기화한다</li>\n<li>방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택한다</li>\n<li>해당 노드를 거쳐 다음 노드로 가는 비용을 계산한다. 다음 노드로 가는 비용을 기존에 구해놓은 값이 있다면, 새로 구한 값과 기존값중 최소값으로 비용 리스트를 갱신한다</li>\n<li>3~4번 과정을 반복한다</li>\n</ol>\n<p>💡 <strong>다익스트라 알고리즘에서 <code class=\"language-text\">heap</code>을 사용하는 이유</strong></p>\n<p>힙을 이용하지 않고 일반 리스트를 이용한다면 매번 최단 거리가 짧은 노드를 선형 탐색해야 하기 때문에 시간이 오래 걸린다.</p>\n<p>힙 자료구조를 이용하면 최솟값이 Root에 오는 특징을 이용해 <strong>출발 노드로부터 가장 거리가 짧은 노드를 더 빠르게 찾을 수 있다!</strong></p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token keyword\">import</span> heapq\n\nN<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">,</span> X <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\nvalues <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>sys<span class=\"token punctuation\">.</span>maxsize<span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 거리배열 int의 최댓값으로 초기화</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>M<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    A<span class=\"token punctuation\">,</span> B <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    graph<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 모든 거리가 1이기 때문에 거리를 따로 저장할 필요 없이 이렇게만 저장해준다</span>\n\n\nheap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># 거리가 가장 작은 것이 root에 올 수 있게 최소힙 만듬 (출발도시에서 가까운 도시부터 탐색하기 위해)</span>\nheapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> X<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># (해당 도시까지 가는 거리, 도시 번호)</span>\nvalues<span class=\"token punctuation\">[</span>X<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">while</span> heap<span class=\"token punctuation\">:</span>\n    v_now<span class=\"token punctuation\">,</span> now <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> v_now <span class=\"token operator\">></span> values<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># 이미 now까지 가는 최단거리가 구해져 있다면 굳이 계산할 필요 없음. 아래 로직 무시</span>\n        <span class=\"token keyword\">continue</span>\n    <span class=\"token keyword\">for</span> <span class=\"token builtin\">next</span> <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>  \n        v <span class=\"token operator\">=</span> v_now <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">if</span> v <span class=\"token operator\">&lt;</span> values<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span> <span class=\"token comment\"># 새로 구한 값이 더 최단거리이면</span>\n            values<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> v  <span class=\"token comment\"># 새로 구한 값으로 거리배열 갱신</span>\n            heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span> <span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ncnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>values<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> values<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> K<span class=\"token punctuation\">:</span>\n        cnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cnt <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3 id=\"-bfs너비우선탐색-알고리즘-사용\" style=\"position:relative;\"><a href=\"#-bfs%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9\" aria-label=\" bfs너비우선탐색 알고리즘 사용 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✅ BFS(너비우선탐색) 알고리즘 사용</h3>\n<p>⚡ 모든 거리가 동일하기 때문에 BFS로도 풀이가 가능하다  </p>\n<p>(출발노드로부터 특정 레벨의 노드까지의 거리보다 <strong>그 다음 레벨의 노드까지의 거리가 무조건 큼</strong>을 보장할 수 있기 때문)</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> sys\n<span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> deque\n\nN<span class=\"token punctuation\">,</span> M<span class=\"token punctuation\">,</span> K<span class=\"token punctuation\">,</span> X <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ngraph <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">for</span> _ <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\nvalues <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>N<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># 거리배열 -1(아직 방문하지 않았음을 의미)로 초기화</span>\nvalues<span class=\"token punctuation\">[</span>X<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>M<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n   A<span class=\"token punctuation\">,</span> B <span class=\"token operator\">=</span> <span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> sys<span class=\"token punctuation\">.</span>stdin<span class=\"token punctuation\">.</span>readline<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strip<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n   graph<span class=\"token punctuation\">[</span>A<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>B<span class=\"token punctuation\">)</span>\n\nqueue <span class=\"token operator\">=</span> deque<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>X<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">while</span> queue <span class=\"token punctuation\">:</span>\n    now <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span>popleft<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\"># queue에서 앞에서부터 꺼냄 = 같은 레벨의 노드 모두 탐색 후 다음 레벨로 이동 (BFS)</span>\n    <span class=\"token keyword\">for</span> <span class=\"token builtin\">next</span> <span class=\"token keyword\">in</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">if</span> values<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span>  <span class=\"token comment\"># next에 아직 방문하지 않은 경우에만 거리배열 갱신 (이미 방문 했다면 이전 레벨에서 구한 값이 무조건 더 작을 것이므로)</span>\n            values<span class=\"token punctuation\">[</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> values<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">]</span><span class=\"token operator\">+</span><span class=\"token number\">1</span>  \n            queue<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># for문을 다 돌고 나면 다음 레벨로 이동</span>\n\ncnt <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>values<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> values<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> K<span class=\"token punctuation\">:</span>\n        cnt <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> cnt <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>","tableOfContents":"<ul>\n<li><a href=\"/Algorithm/%5B%EB%B0%B1%EC%A4%80%5D18352/#%EB%AC%B8%EC%A0%9C\">문제</a></li>\n<li>\n<p><a href=\"/Algorithm/%5B%EB%B0%B1%EC%A4%80%5D18352/#%ED%92%80%EC%9D%B4\">풀이</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"/Algorithm/%5B%EB%B0%B1%EC%A4%80%5D18352/#-%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9\">✅ 다익스트라 알고리즘 사용</a></li>\n<li><a href=\"/Algorithm/%5B%EB%B0%B1%EC%A4%80%5D18352/#-bfs%EB%84%88%EB%B9%84%EC%9A%B0%EC%84%A0%ED%83%90%EC%83%89-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9\">✅ BFS(너비우선탐색) 알고리즘 사용</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"[백준] 18352번 - 특정 거리의 도시 찾기 (파이썬)","date":"October 26, 2021"}}},"pageContext":{"slug":"/Algorithm/[백준]18352/","previous":{"fields":{"slug":"/Algorithm/힙/"},"frontmatter":{"title":"[Algorithm] 힙(Heap)"}},"next":{"fields":{"slug":"/Algorithm/[프로그래머스]가장먼노드/"},"frontmatter":{"title":"[프로그래머스] 가장 먼 노드 (파이썬)"}}}}}