

<모의면접 질문>

1. 자기소개
2. 이전 직장에서 했던 일? 느꼈던 개선필요사항? => IT적으로 연결하기
3. 프론트엔드 개발자로서 가장 중요하다고 생각하는 역할 3가지?
4. 최근 본 IT 관련 기사?
5. 지난 프로젝트에서 했던 역할?
6. PM으로써 본인이 잘 했던 점?
7. 자바, 파이썬 수준?
8. 



<피드백>

1. 자기소개할때 먼저 본인 경력이 개발과 관련없다고 말할 필요 없음. 전 직장에서의 경험을 최대한 IT적으로 풀기. / 이런 시스템에 불편함 느낌 => UX에 관심 => 작동원리까지 관심.. 이런식으로
2. 최근 본 IT 관련 뉴스 "기술적인 걸로"  정말 IT에 관심 있는 느낌 들도록
3. 거시적, 비즈니스적이 아니라 기술적으로 답하기









자기소개

안녕하십니까 프론트엔드 개발자를 지망하는 장혜민이라고 합니다.

사실 저는 원래 영업관리 직무로 일을 했었는데요, 다른 부서에서 만든 서비스를 가맹점에 전달하는 역할을 주로 하다 보니, 직접 서비스를 개발하고 싶다는 갈망이 점점 커져서 개발 공부를 시작하게 되었습니다. 그리고 그 중에서도 고객과 가까이 일했었던 제 특징을 살려 프론트엔드 개발자를 지망하게 되었습니다. 

전공자들에 비해 개발을 접한 경력이 짧다고 생각할 수 있겠지만, 저는 엔코아 교육 시작 후 제 강점이라고 할 수 있는 빠른 적응력과 습득력 그리고 이해가 될때까지 붙잡고 늘어지는 끈기를 발휘해서, 프로젝트 때는 동기 수강생들의 추천을 받아 PM 역할을 할 정도로  빠르게 성장했습니다. 앞으로 제가 배워나가야 할 기술들이 아직 무궁무진하게 남았겠지만 지금까지 해왔던것처럼 빠르게 습득하고 적용하는 개발자가 될 수 있을 거라고 생각합니다. 감사합니다.  





## CORS

다른 도메인으로부터 리소스가 요청될 경우 `cross-origin HTTP 요청`에 의해 요청된다. 하지만 대부분의 브라우저는 `same-origin-policy(동일 근원 정책)`에 의해 cross origin http 요청을 제한한다. 

우회 방법으로 JSONP, IFRAME IO, CrossDomain Proxy 등이 고안됨 (보안취약 등등 문제 있음)



HTML5에서 CORS 스펙이 추가됨.

`Cross-Origin Resource Sharing`은 추가 HTTP 헤더를 사용하여 **다른 출처의 자원에 접근**할 수 있는 권한을 부여하도록 **브라우저에 알려주는** 체제이다. 



### cors 요청의 종류

1. Simple Request

   - Preflight 요청 없이 바로 본 요청을 보내는 경우
   - GET, POST, HEAD 메서드 중 하나일 것
   - Content-Type이 application/x-www-form-urlencoded, multipart/form-data, text/plain 셋 중 하나일 것
   - 헤더는 Accept, Accept-Language, Content-Language, Content-Type 만 허용될 것

2. Preflight Request

   - OPTIONS 메서드를 통해 본 요청을 보내도 되는지 사전확인 하는 작업.

   - XMLHttpRequest 객체가 preflight, actual 요청을 자동으로 처리함. (자동으로 2개의 요청 보냄)

   - Origin (요청 출처) / Access-Control-Request-Method (실제 요청의 메서드) / Access-Control-Request-Headers (실제 요청의 헤더) => 3가지 정보를 담아 prefilght 요청 보내게 됨

   - 그에 대한 응답에는 Access-Control-Allow-Origin (서버측 허가 출처) / Access-Control-Allow-Methods (서버측 허가 메서드) / Access-Control-Alllow-Headers (서버측 허가 헤더) / Access-Control-Max-Age (preflight 응답 캐시 시간)  => 4가지 정보가 담겨오게됨

   - 왜 preflight 요청이 필요한가 ???? : 실제 요청을 서버가 다 수행한 후에 브라우저가 cors 에러를 뱉어봤자 이미 늦음

     

3. Request with Credential

   - 인증 관련 헤더를 포함할 때 사용하는 요청
   - 서버 측에서 Access-Control-Allow-Credentials : true 설정을 해줘야함 / 그리고 이 경우 Access-Control-Allow-Origin: * 로 설정 불가. 정확한 오리진 설정을 해야함

4. Request without Credential

????





### CORS 적용 방법

1. 프론트 proxy 서버 설정
   - 브라우저에서 3000포트 origin으로 요청 보냄 -> **프론트 서버에서 타겟을 8080 포트로 보내도록 설정** -> 백서버 입장에서는 
2. 직접 헤더에 설정해주기 - 귀찮은일임
3. 스프링부트 설정
   - @CrossOrigin(origins = "http://localhost:3000")
   - 또는 Configuration 클래스를 만들어서 전역적으로 설정







## 크로스 브라우징 전략

- 라이브러리 사용 (jQuery, underscore.js, extJS, HTML5 polyfill)
- feature detection: 
- reset.css 
- prefix 적어주기 - 모든 브라우저에서 지원하는 호환 





## UX UI

UX

사용자 경험. 

ex) 상품 검색이라는 행위 전체를 관통하는 사용자 경험에 대한 것

사용자 반응에 따라 변화하는 디자인(클릭? 마우스오버? 뒤로가기?), 

애니메이션, 

좋은 반응성(SPA), 

적절한 정보의 노출, 

적절한 오류페이지 보여주기 (무한히 기다리지 않도록)

불필요한 데이터 사용량 줄이기(필요한 정보만 렌더링)



UI

ex) 검색창, 페이지 디자인 같은 이용 수단이나 대상에 대한 부분

UI의 요소

1. Input Controls : 정보를 입력하는 부분. 회원가입, 프로필관리 등
2. Navigational Components : 웹사이트에서의 이동 안내
3. Informational Components: 정보 제공
4. Containers : 관련된 컨텐츠 함께 묶어놓기









## typescript

사용이유

- 변수의 타입을 지정함으로써 동적 언어인 자바스크립트를 정적 언어처럼 사용 가능. 컴파일 시점에 미리 오류를 발견해서 버그를 줄일 수 있음. 프로젝트 규모가 커졌을 때 혼돈 방지.

- 객체 지향 프로그래밍 지원. 클래스/인터페이스/상속/모듈 등과 같은 객체 지향 프로그래밍 패턴 사용 가능.





## JavaScript ES6

- 화살표함수
- let, const
- 템플릿 리터럴
- 구조분해할당
- Promise
- Class (prototype)

- 모듈 (import, export)





## Promise

프로미스 객체는 콜백함수를 바로 호출하는 게 아니라 resove / reject를 호출한다

resolve에 파라미터로 넘겨준 데이터가 .then() 내에 들어가게 된다





## REST API

구성요소

- 자원 (URI)  : URI를 통해 자원을 명시
- 행위 (GET, POST, PUT, DELETE) 를 통해
- 표현 (Json) : Crud operation 적용

조건

- 클라이언트 - 서버 구조
- 무상태 (각 요청은 서로 연결돼있지 않음)
- 자기기술적



태도랑 목소리 빠르기 등은 매우 좋았습니당. 오늘은 조금 너무 간략하게 대답한다는 느낌이 있었는데 더 준비되면 대답 길이를 조금 늘려도 좋을듯..



## 웹 동작 원리

1. 사용자가 주소 입력
2. 브라우저가 DNS에게 특정 사이트의 주소 요청
3. DNS가 사이트의 IP주소 응답
4. 브라우저가 웹서버에게 IP주소를 이용하여 html 문서 요청
5. 웹서버가 웹 어플리케이션 서버와 데이터베이스에서 웹페이지 작업을 처리
6. 웹서버는 html 문서 결과를 응답
7. 화면에 웹페이지 출력



브라우저의 처리 단계

1. 서비스 이동 단계 (특정 주소로 이동)
2. 리다이렉트 단계 (단축 URL을 사용했다거나 하는 경우)
   - 메타태
3. 애플리케이션 캐시 확인 단계
4. 네트워크 통신 단계
5. 브라우저 처리 단계 : 다운로드한 웹페이지와 구성요소로 화면에 그리기



## MVVM 패턴

controller 대신 viewmodel

mvc에서 유저 상호작용이 일어났음을 뷰가 컨트롤러로 알리고 그에따라 어떤 행동을 할지 모두 컨트롤러가 정했다면, 뷰모델은 로직만 가지고 있고 어떤 행동을 할지는 뷰가 정한다.





## 클로저

**자신이 선언될 당시의 환경을 기억하는 함수**

**함수 + 함수가 선언된 어휘적 환경의 조합**

**클로저의 핵심은 스코프를 이용해서 변수의 접근 범위를 "닫는" 것에 있다**

클로저 안에 정의된 함수는 만들어진 환경을 기억한다.

> Lexical Scoping 
>
> 자바스크립트가 변수의 유효범위를 지정하는 메커니즘.
>
> 함수가 선언되는 시점에 함수가 사용하는 변수를 어디에서 참조해올 것인가를 결정.
>
> 함수 호출 지점을 기준으로 탐색하는 것이 아니라 "선언된 시점"의 환경을 고려하여 정한다. 함수가 호출될 때 선언 시점에 미리 정해진 변수 위치를 참조한다.
>
> (참조할 수 있는 값이 나올 때까지 자기 스코프에서부터 범위를 확장하며 변수를 탐색한다.)



![img](https://media.vlpt.us/images/mygomi/post/029b14da-99db-4f06-93dc-cc44db9db7d7/React.png)

클로저는 위 그림에서 보라색 영역에 해당하는 함수와 그를 둘러싼 환경을 칭하는 말이다.

lexical scoping에 의해 함수 선언 시점에 참조할 변수가 결정되고 나면 name이 다른 값을 가리키게 할 수 없다. 

여기서 name처럼 클로저 함수의 매개변수도 아니고 클로저 함수 내부에서 생성한 변수도 아닌 경우를 **자유변수**라고 한다. 클로저가 자유변수를 기억하는 함수라고 불리는 이유이다.





1. 첫번째 형태 - 중첩함수

```javascript
function outerFn() {
    let x = 10;
    
    return function innerFn(y) {  // innerFn = 클로저
        return x = x+y;
    }
}

let a = outerFn();  // outerFn이라는 외부 함수 호출은 한번만. 
// 이제 a라는 변수는 innerFn을 참조하게된다

a(5); // 15
a(5); // 20  
a(5); // 25
```

```javascript
function makeFunc(){
    var name = '보리';
    function displayName(){  // 클로저 - 선언될 당시의 환경 (name = '보리') 기억함
        alert(name);
    }
    return displayName;
}

var myFunc = makeFunc();  // myFunc이라는 변수에 displayName 함수를 할당
myFunc();  // 보리

```



2. 두번째 형태 - 전역에 선언한 변수를 블록에서 함수로 정의하고 전역에서 호출

```javascript
let globalFn;

{
    let x = 10;
    globalFn = function(y){  // globalFn = 클로저
        return x = x+y;
    }
}

globalFn(5);  // 15
globalFn(5);  // 20
globalFn(5);  // 25
```



### 클로저를 사용하는 이유

1. 상태유지
   - 현재 상태를 기억하고 변경된 최신 상태를 유지
2. 전역 변수 사용 억제
   - 
3. 
   - 데이터를 보존할 수 있다 : 외부 함수의 실행이 끝나더라도 외부 함수 내 변수를 사용할 수 있다. = 특정 데이터를 스코프 안에 가두어둔 채로 계속 사용할수 있게 하는 폐쇄성을 갖는다

- 접근제한(은닉화, 캡슐화) : 
- 모듈화에 유리 : 클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있음 = 클로저를 통해 데이터와 메소드를 묶어다닐 수 있음







### 클로저를 통한 은닉화

Prototype 을 통한 자바스크립트 객체지향 프로그래밍???

```javascript
function hello(name) {
    var _name = name;
    return function() {
        console.log('Hello, ' + _name);
    };
}

var hello1 = hello('보리');
var hello2 = hello('리태');

hello1();  // Hello, 보리
hello2();  // Hello, 리태
```

- 콘솔 로그 찍는 즉시실행함수가 hello1 이라는 변수에 담긴다

- _name이라는 변수는 동적으로 변화하는 것이 아니라 사실은 여러 번 생성되는 것. 각각 새로운 환경이 생성되는 것이다.

- 외부에서 _name이라는 변수에 직접 접근하는 것을 막을 수 있음

  



### 반복문 클로저

```javascript
var i;
for (i = 0; i < 10; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
```

위와 같이 하면 10만 열번 찍힌다. 왜냐면 setTimeout에 인자로 넘긴 익명함수가 각각 0.1초마다 호출되기 전에, 이미 반복문이 모두 순회돼서 i값이 이미 10이 된 상태로 참조하기 때문이다.

클로저를 사용해서 아래와 같이 만든다.

```javascript
var i;
for (i = 0; i < 10; i++) {
    (function(j){  // IIFE(즉시실행함수)
        setTimeout(function() {  // setTimeout()에 걸린 익명함수를 클로저로 만든다.
            console.log(j);
        }, 100);
    })(i);  // 즉시실행함수에 서로 다른 i를 j의 형태로 넘긴다 => 10개의 환경
}
```

클로저는 "만들어진 환경을 기억한다". 여기에서 i는 즉시실행함수 내에 j 형태로 주입된다. 반복문이 10번 반복되면서 10개의 환경이 생길 것이기 때문에 서로 다른 j가 생긴다.

 

### 클로저의 성능 - 참조 제거

클로저는 각자의 환경을 가지므로 환경을 기억하기 위해 당연히 메모리가 소모된다. 클로저를 통해 내부 변수를 참조하는 동안에는 내부 변수가 차지하는 메모리를 GC가 회수하지 않는다. 따라서 클로저 사용이 끝나면 참조를 제거하는 것이 좋다.

```javascript
function hello(name) {
  var _name = name;
  return function() {
    console.log('Hello, ' + _name);
  };
}

var hello1 = hello('보리');
var hello2 = hello('리태');

hello1(); // 'Hello, 보리'
hello2(); // 'Hello, 리태'

// 여기서 메모리를 release 시키기위해 클로저의 참조를 제거해야 한다.
hello1 = null;
hello2 = null;
```





기타 예시들...

```javascript
function makeSizer(size) {
    return function() {
        document.body.style.fontSize = size + 'px';  // 클로저
    }
}

var size12 = makeSizer(12);

document.getElementById('size-12').onclick = size12;
```

```html
<a href="#" id='size-12'>클릭해보세요</a>
```





```javascript
(function(){
    var count = 0;
    var button = document.createElement("button");
    button.innerText = "클릭해주세요";
    button.addEventListener("click", function(){
        console.log(++count, "times clicked");
    })
    document.body.appendChild(button); // 내부함수를 외부에 전달 - 클로저
})();
```

지역변수(count, button)를 참조하는 내부함수를 외부에 전달했기에 클로저는 맞지만, "외부로 전달"이 항상 return을 의미하는 것은 아니다!!!









-----------------------



## call, apply, bind

명시적으로 this를 Window가 아닌 다른 객체로 바꿔주는 함수!!



### 여기서 **this**란 ???

기본적으로는 window.

```javascript
var obj = {
    a: function(){console.log(this);}       
}

obj.a();  // obj
```

객체 메서드 a 안의 this는 객체를 가리킨다. 이것은 객체의 메서드를 호출할 때 this가 내부적으로 바뀌기 때문.

```javascript
var a2 = obj.a;
a2();  // window
```

여기서 a2는 더이상 obj의 메서드가 아님. 그냥 a라는 함수를 꺼내왔을뿐. 

그래서 this가 window가 나온다.

```javascript
var obj2 = { c: 'd'};

function b(){
    console.log(this);
}

b();  // window

// this를 바꾸는 함수 메서드 삼총사 사용하면?
b.bind(obj2).call();  // obj2
b.call(obj2);  // obj2
b.apply(obj2);  // obj2
```



생성자의 경우

```javascript
function Person(name, age){
    this.name = name;
    this.age = age;
}

Person.prototype.sayHi = function(){  // 참고 - Person이라는 객체를 복사 ????????????
    console.log(this.name, this,age);
}


var hero = new Person('Hero', 33);  
hero.sayHi();  // Hero 33
```

이렇게 new를 붙이면 this가 생성자를 통해 생성된 인스턴스 (hero 자신)이 된다.



> 참고:
>
> 자바스크립트는 클래스라는 개념이 없다.
>
> 그래서 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 기반의 언어이다.



### ES6의 화살표함수는 this로 window 대신 상위 함수의 this를 가져온다

```javascript
$('div').on('click', function() {
  console.log(this); // <div>
  function inner() {
    console.log('inner', this); // inner Window
  }
  inner();
});
```

비록 제이쿼리가 클릭 이벤트가 발생할 때 내부적으로 this를 div로 바꾸긴 하지만, inner의 this는 원래대로 window임....

이걸 해결할려면

```javascript
$('div').on('click', function() {
  console.log(this); // <div>
  const inner = () => {
    console.log('inner', this); // inner <div>
  }
  inner();
});
```

화살표함수를 쓴다. 





https://www.zerocho.com/category/JavaScript/post/5b0645cc7e3e36001bf676eb



### call

이미 할당되어 있는 다른 객체의 함수/메소드를, 호출하는 해당 객체에  재할당할 때 사용.

`func.call(thisArg [, arg1 [, arg2 [, ...]]])`

- thisArg : func 호출에 제공되는 this의 값
- arg1, arg2, ... : func이 호출되어야 하는 인수

```javascript
let person1 = {
    name: '보리'
};

let person2 = {
    name: '리태',
    study: function(){
        console.log(this.name + '이/가 공부를 하고 있습니다.');
    }
}

person2.study();  // 리태가 공부를 하고 있습니다.

person2.study.call(person1);  // 보리가 공부를 하고 있습니다.
```

call 메소드 첫번째 매개변수에 person1을 넣어주고 있기 때문에 this.name이 '보리'를 가리키게 됨

```javascript
function Product(name, price){
    this.name = name;
    this.price = price;
}

function Food(name, price){
    Product.call(this, name, price);
    this.category = 'food';
}

console.log(new Food('cheese', 5).name);  // cheese
```

```javascript
const obj = { name : 'bori'};

const say = function(city){
    console.log(`My name is ${this.name}, I live in ${city}`);
}

say('seoul');  // My name is , I live in seoul
say.call(obj, 'seoul');  // My name is bori, I live in seoul
say.apply(obj, ['seoul']);  // My name is bori, I live in seoul
```



### apply

`func.apply(thisArg, [argsArray])`

- thisArg : func 호출에 제공되는 this의 값
- argsArray: func이 호출되어야 하는 인수를 지정하는 유사 배열 객체



call과 apply의 차이점은 파라미터를 입력하는 방식밖에 없다. apply는 배열 형태로 집어넣는다.





### bind

```javascript
const obj = { name : 'bori'};

const say = function(city){
    console.log(`My name is ${this.name}, I live in ${city}`);
}

const boundSay = say.bind(obj);
boundSay('seoul');  // My name is bori, I live in seoul
```

bind 함수가 call, apply와 다른 점은 **함수를 실행하지 않고 대신 bound 함수를 리턴한다**는 점이다.

이 리턴된 bound 함수는 this로 obj를 갖고 있기 때문에 나중에 사용하면 된다. 







-----------------



## event loop, event delegation

### 이벤트 등록



























----------------



## virtual dom









## 비동기처리 (callback, promise, async, await)





## REST와 웹 통신 원리



## typescript





## Redux... 리팩토링 해보자......





## CI CD 해보자....

